{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["Cloth","props","_this","Object","classCallCheck","this","threadCount","possibleConstructorReturn","getPrototypeOf","call","border","pinholes","getPinholes","neighbours","getPinholeNeighbours","state","pinholeNeighbours","paths","width","height","resizeListener","undefined","borderSize","needleIndex","Math","floor","random","length","thread_index","path","thread_goal_iter","goalIndex","goalPath","getPathBetweenPoints","concat","push","color","getRandomColor","r","dr","output","x","y","dx","dy","l","L","sqrt","i","goal","_this2","reduce","o","v","ph","dist_to_goal","pow","index_a","index_b","next","getNextPinhole","_this3","setState","window","innerWidth","innerHeight","draw","ctx","refs","canvas","getContext","midX","midY","radius","min","innerRadius","fillStyle","beginPath","rect","fill","pinhole","arc","PI","lineWidth","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","value","strokeStyle","begin","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","pathIndex","point","moveTo","lineTo","err","return","stroke","_this4","resize","addEventListener","removeEventListener","react_default","a","createElement","ref","React","Component","App","App_Cloth","Boolean","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.2a7408f8.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\n\nclass Cloth extends React.Component {\n    getPinholes(threadCount, border) {\n        const r = 1 - border * 2;\n        const dr = 2 * r / threadCount;\n        var output = [];\n        for(var x=-r; x<=r; x+=dr) {\n            for(var y=-r; y<r; y+=dr) {\n                var dx = 0.002 * (Math.random() - 0.5);\n                var dy = 0.002 * (Math.random() - 0.5);\n                output.push({x: x + dx, y: y + dy});\n            }\n        }\n        return output;\n    }\n\n    getPinholeNeighbours(pinholes) {\n        var neighbours = {}\n        var l = pinholes.length; \n        var L = Math.sqrt(l);\n        var x = null;\n        for(var i=0; i<l; i++) {\n            neighbours[i] = [];\n            if(i + 1 % L > i) {\n                neighbours[i].push(i + 1);\n                if((i + 1 + L) < l )\n                    neighbours[i].push(i + L + 1);\n\n                if((i + 1 - L) >= 0 )\n                    neighbours[i].push(i - L + 1);\n            }\n\n            if((i - 1 + L) % L < i) {\n                neighbours[i].push(i - 1);\n\n                if((i - 1 + L) < l )\n                    neighbours[i].push(i + L - 1);\n\n                if((i - 1 - L) >= 0 )\n                    neighbours[i].push(i - L - 1);\n            }\n\n            if(i + L < l)\n                neighbours[i].push(i + L);\n\n            if(i - L >= 0)\n                neighbours[i].push(i - L);\n\n        }\n        return neighbours\n    }\n\n    constructor(props) {\n        super(props)\n        var threadCount = this.props.threadCount || 200;\n        var border = this.props.border || 0.02;\n        var pinholes = this.getPinholes(threadCount, border);\n        var neighbours = this.getPinholeNeighbours(pinholes);\n\n        this.state = {\n            pinholes: pinholes,\n            pinholeNeighbours: neighbours,\n            paths: [],\n            width: this.props.width,\n            height: this.props.height,\n            resizeListener: undefined,\n            threadCount: threadCount,\n            borderSize: border,\n        }\n\n        var needleIndex = Math.floor(Math.floor(Math.random() * this.state.pinholes.length))\n        for(var thread_index=0; thread_index<5; thread_index++) {\n            var path = [needleIndex];\n            for(var thread_goal_iter=0; thread_goal_iter<5; thread_goal_iter++) {\n                var goalIndex = Math.floor(Math.random() * this.state.pinholes.length);\n                var goalPath = this.getPathBetweenPoints(needleIndex, goalIndex);\n                path = path.concat(goalPath);\n                needleIndex = goalIndex;\n            }\n            this.state.paths.push({\n                path: path,\n                color: this.getRandomColor()\n            });\n        }\n    }\n\n    getNextPinhole(i, goal) {\n        var min = this.state.pinholeNeighbours[i].reduce((o, v) => {\n            var ph = this.state.pinholes[v];\n            var dist_to_goal = Math.sqrt(Math.pow(ph.x - goal.x, 2) + Math.pow(ph.y - goal.y, 2));\n            if(dist_to_goal < o[0])\n                return [dist_to_goal, v];\n            else\n                return o;\n        }, [100000, undefined]);\n        return min[1];\n    }\n\n    getPathBetweenPoints(index_a, index_b) {\n        var output = [index_a];\n        var goal = this.state.pinholes[index_b];\n        var next = index_a;\n\n        while(true) {\n            next = this.getNextPinhole(next, goal); \n            if(next === index_b)\n                break;\n            output.push(next);\n        }\n\n        output.push(index_b);\n        return output;\n    }\n\n    getRandomColor() {\n      var letters = '0123456789ABCDEF';\n      var color = '#';\n      for (var i = 0; i < 6; i++) {\n        color += letters[Math.floor(Math.random() * 16)];\n      }\n      return color;\n    }\n\n    resize() {\n        this.setState({\n            width: window.innerWidth,\n            height: window.innerHeight\n        }, () => this.draw())\n    }\n\n    draw() {\n        const canvas = this.refs.canvas;\n        const ctx = canvas.getContext(\"2d\");\n        const midX = this.state.width / 2;\n        const midY = this.state.height / 2;\n        const radius = Math.min(midX, midY) * 0.9;\n        const innerRadius = (1.0 - this.state.borderSize * 2) * radius;\n\n        ctx.fillStyle = '#c19a6b';\n        ctx.beginPath();\n        ctx.rect(midX - radius, midY - radius, 2 * radius, 2 * radius);\n        ctx.fill();\n\n        ctx.fillStyle = '#F1F1D4';\n        ctx.beginPath();\n        ctx.rect(midX - innerRadius, midY - innerRadius, 2 * innerRadius, 2 * innerRadius);\n        ctx.fill();\n\n        for(var i=0; i<this.state.pinholes.length; i++) {\n            var pinhole = this.state.pinholes[i];\n            ctx.fillStyle = '#FFF';\n            var x = midX + radius * pinhole.x;\n            var y = midY + radius * pinhole.y;\n            ctx.beginPath();\n            ctx.arc(x, y, radius / 250, 0, 2 * Math.PI);\n            ctx.fill();\n        }\n\n        ctx.lineWidth = radius / 250;\n        for(var path of this.state.paths) {\n            ctx.strokeStyle = path.color;\n            \n            ctx.beginPath();\n            var begin=true\n\n            for(var pathIndex of path.path) {\n                var point = this.state.pinholes[pathIndex];\n                var x = midX + radius * point.x;\n                var y = midY + radius * point.y;\n                if(begin) {\n                    ctx.moveTo(x, y);\n                    begin=false;\n                } else {\n                    ctx.lineTo(x, y);\n                }\n            }\n            ctx.stroke();\n        }\n    }\n\n    componentDidMount() {\n        this.resize();\n        this.setState({\n            resizeListener: window.addEventListener(\"resize\", () => this.resize())\n        });\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener(\"resize\", this.state.resizeListener);\n    };\n\n    render() {\n        var canvas = <canvas ref=\"canvas\" width={this.state.width} height={this.state.height}></canvas>;\n        return canvas;\n    }\n}\n\nfunction App() {\n  return (\n    <Cloth width=\"64\" height=\"64\" />\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}